> ### ------------------------------------------------------------------------ ###
> ### R script to run WKNSMSE had MSE on HPC ####
> ### ------------------------------------------------------------------------ ###
> ### This is designed to be called by a job submission script
> ### run_mse.qsub for systems using PBS and the qsub commands
> ### run_mse.bsub for system using LSF and the bsub commands
> 
> 
> ### ------------------------------------------------------------------------ ###
> ### load arguments from job script ####
> ### ------------------------------------------------------------------------ ###
> 
> ### load arguments
> args <- commandArgs(TRUE)
> print("arguments passed on to this script:")
[1] "arguments passed on to this script:"
> print(args)
[1] "iters=999"     "years=20"      "nblocks=200"   "par_env=2"    
[5] "n_workers=200" "HCRoption=3"  
> 
> ### evaluate arguments, if they are passed to R:
> if (length(args) > 0) {
+   
+   ### extract arguments
+   for (i in seq_along(args)) eval(parse(text = args[[i]]))
+   
+   ### parallelisation environment
+   if (!exists("par_env")) par_env <- 1
+   if (!exists("n_workers")) n_workers <- 1
+   
+ } else {
+   
+   stop("no argument passed to R")
+   
+ }
> 
> ### ------------------------------------------------------------------------ ###
> ### set up environment ####
> ### ------------------------------------------------------------------------ ###
> 
> ### load packages
> library(FLfse)
Loading required package: FLCore
Loading required package: lattice
Loading required package: iterators
FLCore (Version 2.6.12, packaged: 2019-02-18 08:43:21 UTC)
Loading required package: foreach
> library(stockassessment)
> library(ggplotFL)
Loading required package: ggplot2

Attaching package: ‘ggplot2’

The following object is masked from ‘package:FLCore’:

    %+%

Warning message:
replacing previous import ‘ggplot2::%+%’ by ‘FLCore::%+%’ when loading ‘ggplotFL’ 
> library(FLAssess)
> library(mse)
Loading required package: data.table
Loading required package: FLash
Loading required package: FLBRP

Attaching package: ‘FLBRP’

The following object is masked from ‘package:stockassessment’:

    ypr

> ### load files from package mse for easier debugging
> #devtools::load_all("../mse/")
> library(FLash)
> library(tidyr)

Attaching package: ‘tidyr’

The following objects are masked from ‘package:FLCore’:

    expand, spread

> library(dplyr)

Attaching package: ‘dplyr’

The following objects are masked from ‘package:data.table’:

    between, first, last

The following objects are masked from ‘package:FLCore’:

    combine, desc, n

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

> 
> ### load additional functions
> source("a4a_mse_WKNSMSE_funs.R")
> invisible(lapply(list.files(path = "functions/", pattern = "*.R$", 
+                             full.names = TRUE), source))
> path_out <- paste0("output/had4/runs/", iters, "_", years)
> ### ------------------------------------------------------------------------ ###
> ### setup parallel environment ####
> ### ------------------------------------------------------------------------ ###
> ### par_env=1 -> MPI (Rmpi, DoMPI)
> ### par_env=2 -> DoParallel
> 
> ### ------------------------------------------------------------------------ ###
> ### set HCR parameters 
> ### ------------------------------------------------------------------------ ###
> 
> if (HCRoption %in% 1:6) {
+   
+   
+   # options for extra A (sensitivity and robustness)
+   
+   #optimised pair
+   optimF<-0.28
+   optimB<-160000
+   Fmsy<-0.194
+   Fmsylower<-0.167
+   Fmsyupper<-0.194
+   Bmsy<-132000
+   
+   # 0.9 *Ftrgt
+   hcr_vals<-data.frame(Ftrgt=0.9*optimF,Btrigger=optimB)
+   
+   # 1.1*Ftrgt
+   hcr_vals<-rbind(hcr_vals,c(1.1*optimF,optimB))
+   
+   # Fmsylower
+   hcr_vals<-rbind(hcr_vals,c(Fmsylower,optimB))
+   
+   # Fmsyupper
+   hcr_vals<-rbind(hcr_vals,c(Fmsyupper,optimB))
+   
+   # 1.5*Btrigger
+   #  hcr_vals<-rbind(hcr_vals,c(optimF,optimB*1.5))
+   
+   # 2*Btrigger
+   #  hcr_vals<-rbind(hcr_vals,c(optimF,optimB*2))
+   
+   # A*
+   # hcr_vals<-rbind(hcr_vals,c(Fmsy,Bmsy))
+   
+ }
> 
> if (par_env == 1) {
+   
+   library(doMPI)
+   cl <- startMPIcluster()
+   registerDoMPI(cl)
+   cl_length <- cl$workerCount
+   
+ } else if (par_env == 2) {
+   
+   library(doParallel)
+   cl <- makeCluster(n_workers)
+   registerDoParallel(cl)
+   cl_length <- length(cl)
+   
+   
+ }
Loading required package: parallel
> 
> 
> #if(FALSE){  
> ### load packages and functions into workers
> . <- foreach(i = seq(cl_length)) %dopar% {
+   #devtools::load_all("../mse/")
+   library(mse)
+   library(FLash)
+   library(FLfse)
+   library(stockassessment)
+   library(foreach)
+   library(doRNG)
+   
+   source("a4a_mse_WKNSMSE_funs.R")
+   invisible(lapply(list.files(path = "functions/", pattern = "*.R$", 
+                               full.names = TRUE), source))
+ }
> 
> ### set random seed for reproducibility
> library(doRNG)
Loading required package: rngtools
Loading required package: pkgmaker
Loading required package: registry

Attaching package: ‘pkgmaker’

The following object is masked from ‘package:base’:

    isFALSE

> registerDoRNG(123)
> # }
> ### ------------------------------------------------------------------------ ###
> ### load data for MSE ####
> ### ------------------------------------------------------------------------ ###
> 
> ### data path
> path_data <- paste0("input/had4/")
> 
> omName<-"Baseline"
> MPrunName<-"Base"
> n<-iters
> 
> ### load input objects
> input<-readRDS(file = paste0(path_data,"/MP_base/MP",MPrunName,"_OM",omName,"_",n,".rds"))
> 
> ### modify input for running in parallel
> input$genArgs$nblocks <- nblocks
> 
> 
> 
> ### ------------------------------------------------------------------------ ###
> ### set HCR option: A, B, C
> if (exists("HCRoption")) {
+   
+   input$ctrl.mp$ctrl.hcr@args$option <- switch(HCRoption, 
+                                                "1" = "A", 
+                                                "2" = "B", 
+                                                "3" = "C",
+                                                "4" = "A",
+                                                "5" = "B",
+                                                "6" = "C")
+   
+   cat(paste0("\nSetting custom HCR option: HCRoption = ", HCRoption, 
+              " => HCR ", input$ctrl.mp$ctrl.hcr@args$option, "\n\n"))
+   
+ } else {
+   
+   cat(paste0("\nUsing default HCR option: HCR ", 
+              input$ctrl.mp$ctrl.hcr@args$option, "\n\n"))
+   HCRoption <- 0
+ }

Setting custom HCR option: HCRoption = 3 => HCR C

> 
> input_bckp <- input
> for (HCR_comb in 1:nrow(hcr_vals)) {
+   input <- input_bckp
+   
+   ### implement
+   if (exists("HCR_comb")) {
+     
+     ### set Btrigger
+     Btrigger <- hcr_vals[HCR_comb, "Btrigger"]
+     input$ctrl.mp$ctrl.phcr@args$Btrigger <- Btrigger
+     input$ctrl.mp$ctrl.is@args$hcrpars$Btrigger <- Btrigger
+     
+     ### set Ftrgt
+     Ftrgt <- hcr_vals[HCR_comb, "Ftrgt"]
+     input$ctrl.mp$ctrl.phcr@args$Ftrgt <- Ftrgt
+     input$ctrl.mp$ctrl.is@args$hcrpars$Ftrgt <- Ftrgt
+     
+     cat(paste0("\nSetting custom Btrigger/Ftrgt values.\n",
+                "Using HCR_comb = ", HCR_comb, "\n",
+                "Ftrgt = ", Ftrgt, "\n",
+                "Btrigger = ", Btrigger, "\n\n"))
+     
+   } else {
+     input$ctrl.mp$ctrl.phcr@args$Ftrgt <- Ftrgt
+     input$ctrl.mp$ctrl.is@args$hcrpars$Ftrgt <- Ftrgt
+     input$ctrl.mp$ctrl.phcr@args$Btrigger <- Btrigger
+     input$ctrl.mp$ctrl.is@args$hcrpars$Btrigger <- Btrigger
+     
+     cat(paste0("\nUsing default Btrigger/Ftrgt values.\n",
+                "Ftrgt = ", input$ctrl.mp$ctrl.phcr@args$Ftrgt, "\n",
+                "Btrigger = ", input$ctrl.mp$ctrl.phcr@args$Btrigger, "\n\n"))
+     
+   }
+   
+   ### ------------------------------------------------------------------------ ###
+   ## TAC constraint
+   input$ctrl.mp$ctrl.is@args$TAC_constraint <- FALSE
+   ### check conditions
+   ### either manually requested or as part of HCR options 4-6 
+   if (exists("TAC_constraint")) {
+     
+     if (isTRUE(as.logical(TAC_constraint))) {
+       input$ctrl.mp$ctrl.is@args$TAC_constraint <- TRUE
+     }
+   }
+   if (HCRoption %in% 4:6) {
+     input$ctrl.mp$ctrl.is@args$TAC_constraint <- TRUE
+   }
+   ### implement
+   if (isTRUE(input$ctrl.mp$ctrl.is@args$TAC_constraint)) {
+     
+     input$ctrl.mp$ctrl.is@args$lower <- 80
+     input$ctrl.mp$ctrl.is@args$upper <- 125
+     input$ctrl.mp$ctrl.is@args$Btrigger_cond <- TRUE
+     
+     cat(paste0("\nImplementing TAC constraint.\n\n"))
+     
+   } else {
+     
+     cat(paste0("\nTAC constraint NOT implemented.\n\n"))
+     
+   }
+   
+   
+   ### ------------------------------------------------------------------------ ###
+   ### banking & borrowing
+   ### banking & borrowing
+   input$ctrl.mp$ctrl.is@args$BB <- FALSE
+   input$iem <- NULL
+   
+   ### check conditions
+   ### either manually requested or as part of HCR options 4-6 
+   if (exists("BB")) {
+     if (isTRUE(as.logical(BB))) {
+       
+       input$iem <- FLiem(method = iem_WKNSMSE, args = list(BB = TRUE))
+       input$ctrl.mp$ctrl.is@args$BB <- TRUE
+       input$ctrl.mp$ctrl.is@args$BB_check_hcr <- TRUE
+       input$ctrl.mp$ctrl.is@args$BB_check_fc <- TRUE
+       input$ctrl.mp$ctrl.is@args$BB_rho <- c(-0.1, 0.1)
+       
+     }
+     
+   }
+   if (HCRoption %in% 4:6) {
+     
+     input$iem <- FLiem(method = iem_WKNSMSE, args = list(BB = TRUE))
+     input$ctrl.mp$ctrl.is@args$BB <- TRUE
+     input$ctrl.mp$ctrl.is@args$BB_rho <- c(-0.1, 0.1)
+     input$ctrl.mp$ctrl.is@args$BB_check_hcr <- FALSE
+     input$ctrl.mp$ctrl.is@args$BB_check_fc <- FALSE
+     
+     if (HCRoption %in% 4) {
+       
+       input$ctrl.mp$ctrl.is@args$BB_check_hcr <- TRUE
+       
+     } else if (HCRoption %in% 5:6) {
+       
+       input$ctrl.mp$ctrl.is@args$BB_check_fc <- TRUE
+       
+     }
+     
+   }
+   
+   if (!is.null(input$iem)) {
+     
+     cat(paste0("\nImplementing banking and borrowing.\n\n"))
+     
+   } else {
+     
+     cat(paste0("\nBanking and borrowing NOT implemented.\n\n"))
+     
+   }
+   
+   
+   ### ------------------------------------------------------------------------ ###
+   ### run MSE ####
+   ### ------------------------------------------------------------------------ ###
+   #debugonce(mse:::goFish)
+   print(Sys.time())
+   ### run MSE
+   res1 <- mp(om = input$om,
+              oem = input$oem,
+              iem = input$iem,
+              ctrl.mp = input$ctrl.mp,
+              genArgs = input$genArgs,
+              tracking = input$tracking)
+   
+   print(Sys.time())
+   
+   ### save results
+   path_out <- paste0("output/had4/runs/",omName,"/", n, "_", years)
+   
+   dir.create(path = path_out, recursive = TRUE)
+   file_out <- paste0("HCR-", input$ctrl.mp$ctrl.hcr@args$option,
+                      "_Ftrgt-", input$ctrl.mp$ctrl.phcr@args$Ftrgt,
+                      "_Btrigger-", input$ctrl.mp$ctrl.phcr@args$Btrigger,
+                      "_TACconstr-", input$ctrl.mp$ctrl.is@args$TAC_constraint,
+                      "_BB-", input$ctrl.mp$ctrl.is@args$BB
+   )
+   
+   saveRDS(object = res1, paste0(path_out, "/", file_out, ".rds"))
+ }

Setting custom Btrigger/Ftrgt values.
Using HCR_comb = 1
Ftrgt = 0.252
Btrigger = 160000


TAC constraint NOT implemented.


Banking and borrowing NOT implemented.

[1] "2019-03-01 22:09:42 CET"

[1] "2019-03-01 23:26:16 CET"

Setting custom Btrigger/Ftrgt values.
Using HCR_comb = 2
Ftrgt = 0.308
Btrigger = 160000


TAC constraint NOT implemented.


Banking and borrowing NOT implemented.

[1] "2019-03-01 23:26:19 CET"

[1] "2019-03-02 00:37:39 CET"

Setting custom Btrigger/Ftrgt values.
Using HCR_comb = 3
Ftrgt = 0.167
Btrigger = 160000


TAC constraint NOT implemented.


Banking and borrowing NOT implemented.

[1] "2019-03-02 00:37:41 CET"

[1] "2019-03-02 01:48:41 CET"

Setting custom Btrigger/Ftrgt values.
Using HCR_comb = 4
Ftrgt = 0.194
Btrigger = 160000


TAC constraint NOT implemented.


Banking and borrowing NOT implemented.

[1] "2019-03-02 01:48:43 CET"

[1] "2019-03-02 02:59:12 CET"
Warning messages:
1: In dir.create(path = path_out, recursive = TRUE) :
  'output/had4/runs/Baseline/999_20' already exists
2: In dir.create(path = path_out, recursive = TRUE) :
  'output/had4/runs/Baseline/999_20' already exists
3: In dir.create(path = path_out, recursive = TRUE) :
  'output/had4/runs/Baseline/999_20' already exists
4: In dir.create(path = path_out, recursive = TRUE) :
  'output/had4/runs/Baseline/999_20' already exists
> ### ------------------------------------------------------------------------ ###
> ### combine and plot ####
> ### ------------------------------------------------------------------------ ###
> if(FALSE){output <- readRDS(paste0(path_out, "/", file_out, ".rds"))
+ # ### get stock before simulation
+ stk <- input$om@stock
+ # ### add simulated data
+ stk[, dimnames(res1@stock)$year] <- res1@stock
+ # ### save
+ saveRDS(object = stk, file = paste0(path_out,"/",file_out,"_base_full_stk.rds"))
+ 
+ # ### plot
+ plot(stk, probs = c(0.05, 0.25, 0.5, 0.75, 0.95)) + 
+   xlab("year") + geom_vline(xintercept = 2018.5) +
+   geom_hline(data = data.frame(qname = "SSB", data = 94000), #blim
+              aes(yintercept = data), linetype = "dashed") +
+   geom_hline(data = data.frame(qname = "SSB", data = 132000), #bpa
+              aes(yintercept = data), linetype = "solid") +
+   geom_hline(data = data.frame(qname = "F", data = 0.38), # flim
+              aes(yintercept = data), linetype = "dashed") +
+   geom_hline(data = data.frame(qname = "F", data = 0.274), #fpa
+              aes(yintercept = data), linetype = "solid") +
+   theme_bw()
+ ggsave(filename = paste0(path_out,"/",file_out,"_base_full_stk.png"), 
+        width = 30, height = 20, units = "cm", dpi = 300, type = "cairo")
+ 
+ }
> 
> ### ------------------------------------------------------------------------ ###
> ### terminate ####
> ### ------------------------------------------------------------------------ ###
> 
> ### close R
> # mpi.finalize()
> ### mpi.finalize() or mpi.quit() hang...
> ### -> kill R, the MPI processes stop afterwards
> 
> ### try killing current job...
> # if (par_env == 1 & exists("kill")) {
> #   system("bkill $LSB_JOBID")
> # }
> 
> quit(save = "no")
> proc.time()
     user    system   elapsed 
 3123.345   119.972 17441.627 
